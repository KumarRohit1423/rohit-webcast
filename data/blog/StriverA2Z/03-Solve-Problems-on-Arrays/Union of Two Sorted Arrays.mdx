---
title: Union of Two Sorted Arrays
tags:
  - medium
  - StriverA2Z
date: 2024-06-11T17:39:32
summary: Given two sorted arrays of size **n** and **m** respectively, find their union. The Union of two arrays can be defined as the common and distinct elements in the two arrays. Return the elements in sorted order.
---

Given two sorted arrays of size **n** and **m** respectively, find their union. The Union of two arrays can be defined as the **common** and **distinct** elements in the two arrays. Return the elements in **sorted** order.

**Example 1:**

```
Input:
n = 5, arr1[] = {1, 2, 3, 4, 5}
m = 5, arr2 [] = {1, 2, 3, 6, 7}
Output:
1 2 3 4 5 6 7
Explanation:
Distinct elements including both the arrays are: 1 2 3 4 5 6 7.
```

**Example 2:**

```
Input:
n = 5, arr1[] = {2, 2, 3, 4, 5}
m = 5, arr2[] = {1, 1, 2, 3, 4}
Output:
1 2 3 4 5
Explanation:
Distinct elements including both the arrays are: 1 2 3 4 5.
```

**Example 3:**

```
Input:
n = 5, arr1[] = {1, 1, 1, 1, 1}
m = 5, arr2[] = {2, 2, 2, 2, 2}
Output:
1 2
Explanation:
Distinct elements including both the arrays are: 1 2.
```

**Your Task:**
You do not need to read input or print anything. Complete the function **findUnion()** that takes two arrays **arr1\[\]**, **arr2\[\],** and their size **n** and **m** as input parameters and returns a list containing the **union of the two arrays**.

**Expected Time Complexity:** O(n+m).  
**Expected Auxiliary Space:** O(n+m).

**Constraints:**  
`1 <= n, m <= 10^5`  
`-10^9 <= arr1[i], arr2[i] <= 10^9`

---

# My Approach

```cpp
class Solution {
 public:
  vector<int> findUnion(int arr1[], int arr2[], int n, int m) {
    int ptr1 = 0, ptr2 = 0;
    vector<int> ans;
    while ((ptr1 < n) && (ptr2 < m)) {
      if (arr1[ptr1] == arr2[ptr2]) {
        if (ans.empty()) {
          ans.push_back(arr1[ptr1]);
        } else if (ans.back() != arr1[ptr1]) {
          ans.push_back(arr1[ptr1]);
        }
        ptr1++;
        ptr2++;
      } else if (arr1[ptr1] < arr2[ptr2]) {
        if (ans.empty()) {
          ans.push_back(arr1[ptr1]);
        } else if (ans.back() != arr1[ptr1]) {
          ans.push_back(arr1[ptr1]);
        }
        ptr1++;
      } else {
        if (ans.empty()) {
          ans.push_back(arr2[ptr2]);
        } else if (ans.back() != arr2[ptr2]) {
          ans.push_back(arr2[ptr2]);
        }
        ptr2++;
      }
    }
    if (ptr1 < n) {
      while (ptr1 < n) {
        if (ans.back() != arr1[ptr1]) {
          ans.push_back(arr1[ptr1]);
        }
        ptr1++;
      }
    } else if (ptr2 < m) {
      while (ptr2 < m) {
        if (ans.back() != arr2[ptr2]) {
          ans.push_back(arr2[ptr2]);
        }
        ptr2++;
      }
    }
    return ans;
  }
};
```

# Notes

A lengthy approach but fruitful in the sense that it solves the task in constant space `O(1)` space and `O(m + n)` time.
